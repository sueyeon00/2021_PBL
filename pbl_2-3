#include<stdio.h>
#include<stdlib.h>

#define MAX_QUEUE_SIZE 6

typedef struct {          //구조체 만들기 
	int id;              //element 에는 id, arrival, service 가 있다 
	int arrival_time;
	int service_time;
}element;

typedef struct {                      //구조체 만들기
	element data[MAX_QUEUE_SIZE];     //배열
	int front, rear;
}QueueType;


//오류함수
void error(char* message) {
	fprintf(stderr, "%s\n", message);
	exit(1);
}

//공백 상태 검출 함수
void init_queue(QueueType* q) {
	q->front = q->rear = 0;
}

//공백 상태 검출 함수
int is_empty(QueueType* q) {
	return(q->front == q->rear);
}

//포화 상태 검출 함수
int is_full(QueueType* q) {
	return((q->rear + 1) % MAX_QUEUE_SIZE == q->front);
}

//원형큐 출력함수 
void queue_print(QueueType* q) {
	printf("QUEUE(front =%d rear =%d) =", q->front, q->rear);
	if (!is_empty(q)) {
		int i = q->front;        //q의 front 값을 i라고 함
		do {
			i = (i + 1) % (MAX_QUEUE_SIZE);
			printf("%d |", q->data[i]);  //data배열 == queue
			if (i == q->rear)            //값을 다 출력하면
				break;
		} while (i != q->front);
	}
	printf("\n");
}

//삽입함수
void enqueue(QueueType* q, element item) {
	if (is_full(q))
		error("큐가 포화상태입니다.");
	q->rear = (q->rear + 1) % MAX_QUEUE_SIZE;
	q->data[q->rear] = item;
}

//삭제 함수 
element dequeue(QueueType* q) {
	if (is_empty(q))
		error("큐가 공백상태입니다.");
	q->front = (q->front + 1) % MAX_QUEUE_SIZE;
	return q->data[q->front];
}
//은행원이 2명이라면 창구가 2개  A, B로 시간과 손님 변수를 추가해줌
int main(void) {
	int minutes = 60;
	int total_wait = 0;
	int total_customers = 0;
	int Aservice_time = 0;
	int Aservice_customer;
	int Bservice_time = 0;
	int Bservice_customer;
	QueueType queue;
	init_queue(&queue);

	srand(time(NULL));
	for (int clock = 0; clock < minutes; clock++) {
		printf("<현재시각=%d>\n", clock);
		if ((rand() % 10) < 4) {           //0~10 중 4미만이면 손님이 들어옴
			element customer;
			customer.id = total_customers++;  // 1씩 커짐   
			customer.arrival_time = clock;    //도착한 시간은 현재 시각
			customer.service_time = rand() % 3 + 1;      //서비스 시간 1~3 중 난수 
			enqueue(&queue, customer);     //push 
			printf("고객 %d이 %d분에 들어옵니다. 업무처리시간 = %d분\n", customer.id, customer.arrival_time
				, customer.service_time);
		}

		if (Aservice_time > 0) {        //0이 아니면 현재 서비스 받는 고객이 있다는 의미
			printf("A : 고객 %d 업무처리중입니다. \n", Aservice_customer);
			Aservice_time--;   //clock이 1분씩 늘어나기 때문
		}
		else {
			if (!is_empty(&queue)) {   //대기하고 있는 고객이 있을 때 
				element customer = dequeue(&queue);  //큐에서 하나 빼냄
				Aservice_customer = customer.id;
				Aservice_time = customer.service_time;
				printf("A : 고객 %d이 %d분에 업무를 시작합니다. 대기시간은 %d분이었습니다. \n",
					customer.id, clock, clock - customer.arrival_time);
				total_wait += clock - customer.arrival_time; //전체 대기 시간은 대기시간들 모두 더한 값
			}//대기시간은 아까 도착한 시간에서 업무 시작 시간을 뺀 값 
		}

		if (Bservice_time > 0) {        //0이 아니면 현재 서비스 받는 고객이 있다는 의미
			printf("B : 고객 %d 업무처리중입니다. \n", Bservice_customer);
			Bservice_time--;   //clock이 1분씩 늘어나기 때문
		}
		else {
			if (!is_empty(&queue)) {   //대기하고 있는 고객이 있을 때 
				element customer = dequeue(&queue);  //큐에서 하나 빼냄
				Bservice_customer = customer.id;
				Bservice_time = customer.service_time;
				printf("B : 고객 %d이 %d분에 업무를 시작합니다. 대기시간은 %d분이었습니다. \n",
					customer.id, clock, clock - customer.arrival_time);
				total_wait += clock - customer.arrival_time; //전체 대기 시간은 대기시간들 모두 더한 값
			}//대기시간은 아까 도착한 시간에서 업무 시작 시간을 뺀 값 
		}
	}
	printf("전체 대기 시간은 %d분 입니다. \n", total_wait);
	return 0;
}//if문이 전부 해당하지 않을 때는 그냥 시간만 흐름 
